---
title: 용어정리 2. 데몬(Daemon) 프로세스
categories: [ETC]
---
*‘하둡 클러스터의 master 서버에서 namenode가 데몬으로 실행되고, slave 서버에서 datanode와 task tacker가 데몬으로 실행된다.’*

이 단 한줄의 문장을 이해하기 위해 이 포스팅을 하고있다.

사실 데몬이라는 말을 완전히 모르고 있던것은 아니다. 내가 학원에서 했던 프로젝트 중에 처음 Airflow 사용했을 때, 매번 cmd창을 두개 띄우고 aws에 접속하여 webserver와 scheduler를 켰던 적이 있다. 이때 이게 너무 불편해서 한번에 두개 다 계속 돌아가게 할 수 없나 싶어서 찾다가 알게된게 ‘nohup과 &기호로 webserver와 scheduler를 데몬으로 켜둔다’라는 내용의 블로그 글이였다. 당시에도 데몬이 뭔가 싶어서 잠깐 찾아봤는데 그냥 백그라운드로 실행되는 프로세스라고 하길래 그렇게만 알고 넘어 갔었다.

사실 맨 위의 문장을 이해하는데 ‘데몬은 백그라운드로 실행되는 프로세스다’ 이상의 더 깊은 이해가 필요할까 싶기도하다. 그래도 저번에 대충넘겼으니 그에 대한 업보(?)로써 이번엔 좀 자세히 공부하는게 맞지않나 하는 생각에 이 글을 작성하게 됐다.

# 1. 프로세스(포그라운드와 백그라운드)

데몬에 대한 여러가지 레퍼런스들을 찾아보면, ‘데몬은 프로세스다’라고 쓰여있는 경우들도 왕왕 목격할 수 있다. 데몬이 물론 프로세스이긴하나, 이는 반쪽짜리 정의에 불과하다.

프로세스는 간단하게 표현하면 실행 중에 있는 프로그램을 의미한다. 물론 이런 단순한 의미 이상의 깊은 메커니즘을 가지고 있지만, 어쨌든 이 프로세스라는 건 크게 포라운드와 백그라운드로 구분이된다. 그리고 데몬은 이 중 백그라운드 프로세스의 일종이다. 그럼 포그라운드(Foreground)와 백그라운드(Background) 프로세스는 어떤 차이가 있을까?

사실 그 이름에서 어느정도 유추했듯이 ‘눈 앞에 보이냐 아니면 눈에 보지않느냐’로 프로세스가 구분된다.

포그라운드 프로세스는 사용자가 터미널, 키보드, 마우스 등과 같은 표준 입출력 장치를 통해 대화하는 프로세스를 의미한다. 좀더 linux 친화적으로 말하면 사용자가 tty나 pts를 통해 프로세스와 대화할 수 있는 프로세스를 포그라운드 프로세스라고 한다. 당장 우리 눈앞에 있는 이 엣지 브라우저부터 시작해서, 노션, 슬랙, 메모장, 카카오톡 등이 모두 포그라운드 프로세스이다.

백그라운드 프로세스는 적어도 입력장치에 대해 터미널과의 관계를 끊은 프로세스를 의미한다. 좀 더 쉽게 풀어 말하면, 실행시켜놓으면 알아서 눈에 보이지않는 백그라운드에서 스스로 동작하는 프로세스가 백그라운드 프로세스다.

# 2. 백그라운드 프로세스

사실 데몬을 백그라운드 프로세스라고 하는 경우들이 많다. 나도 이전의 경험속에서 데몬은 백그라운드 프로세스라고 이해하고 있었다.  하지만 엄격히 백그라운드 프로세스와 데몬은 구분된다. 그 구분을 위해 백그라운드 프로세스에 대해 좀 더 알아보도록 하겠다.

(*앞으로의 내용은 [데몬(daemon) 프로세스란 무엇인가? (blogger.pe.kr)](https://blogger.pe.kr/770)의 내용을 따라서 진행한 내용이다. )*

---

개인 windows PC에서 GCP의 인스턴스로 SSH접속을 하는 상황을 가정해보자. 우선 cmd 창을 열것이고 ssh 명령어로 GCP 인스턴스에 접속을 해야한다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d3875d43-54f7-441e-9412-b2a846566fdb/Untitled.png)

ssh 명령어를 사용하는 순간까지는 내 윈도우 pc에서 실행된 cmd의 화면이다. cmd는 C:\Users와 같이 표현되는 프롬프트를 표시하고, 나는 cmd 창에서 ssh 명령어를 키보드로 입력한다. 따라서 cmd는 포그라운드 프로세스이다.

이번엔 다음 라인에 표시되는 Last login: Wed Oct … 에 대해서 알아보자.

cmd는 내가 입력한 ssh명령어를 해석해 PC에 있는 ssh 명령을 실행하고 뒤에 입력받은 GCP 인스턴스의 퍼블릭 IP로의 접속을 시도한다. 그리고 해당 인스턴스에서 실행되고 있는 ssh 데몬(sshd)과 세션을 맺은 후 ssh 데몬(sshd)이 보여주고자 하는 ‘사용자가 인스턴스에 접속한 마지막 시간과 접속 IP’를 전달받아 화면에 출력해준다.

즉, ssh 명령도 화면에 sshd로 부터 전달받은 내용을 표시하고 키보드를 통해 입력한 ssh 명령어를 GCP 인스턴스에 전달하므로 포그라운드 프로세스다.

지금까지 우리는 cmd와 ssh 명령이라는 두 개의 포그라운드 프로세스에 대해 이해했다. 그러면 뒤에 [won21yuk@instance-1]$ 이라고 표시된건 뭘까?

$는 리눅스의 쉘임을 나타내는 기호이다. 우리는 ssh명령어를 통해 GCP 인스턴스에 접속했고 그 GCP 인스턴스는 linux OS이기 때문에 cmd창에 $라는 기호가 생겨난 것이다. 그럼 sshd가 $를 화면에 띄워주고 사용자의 입력을 기다리므로 sshd는 포그라운드 프로세스일까?

결론부터 말하자면 sshd는 포그라운드 프로세스가 아니다. 그 이유는 sshd의 역할에 있다.

sshd는 ssh를 통해 내 로컬에 가지고 있는 공개키와 GCP 인스턴스에 등록된 공개키가 같은지 확인하고 일치하는 경우 접속을 허용하여 해당 계정에 할당된 bash를 실행시킨 후 뒤로 물러난다.

따라서 화면에 표시된 $ 기호는 sshd가 출력한게 아니라 **sshd가 실행시킨 bash가 출력한 것**이다. 결국 sshd 그 자체는 사용자로부터 어떠한 입력을 받지도 않고 직접 무언가를 출력하지도 않았다.

이를 좀더 자세히 보기위해 프로세스들간의 관계를 살펴보도록 하겠다.

```bash
# ps -ef
					 PID  PPID
root      1168     1  0 12:07 ?        00:00:00 /usr/sbin/sshd -D
.
.
.
root      1642  1168  1 12:58 ?        00:00:00 sshd: won21yuk [priv]
won21yuk  1645  1642  0 12:58 ?        00:00:00 sshd: won21yuk@pts/0
won21yuk  1646  1645  0 12:58 pts/0    00:00:00 -bash
[won21yuk@instance-1 ~]$
```

위의 내용은 GCP 인스턴스에서 ps -ef명령어로 실행되고있는 프로세스 목록을 출력한 것이다. 여기서 중요하게 봐야할 건 PID와 PPID이다.

> **PID**
: Process ID의 줄임말이다. Linux 운영체제에서 프로세스를 식별하기 위해 부여한 번호이다.
>

> **PPID**
: Parent Process ID의 줄임말이다. 부모 프로세스의 PID를 의미한다.
>

맨 첫단에 보면 root 계정으로 실행된 sshd -D 프로세스(**PID 1168**)를 확인할 수 있다. 그리고 아래에 PPID가 1168인 sshd(**PID 1642**)가 보인다. 그 아래에는 won21yuk 계정으로 실행된 sshd 프로세스(**PID 1645**)가 있고 PPID는 1642이다. 마지막으로  bash 프로세스(**PID 1646**)가 있고 PPID는 1645다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1261fb09-7440-43a0-ae94-fb2270aa9ad6/Untitled.png)

이 관계는 root 계정에서 실행된 sshd(**PID 1168**)가 won21yuk 계정에서 실행되는 sshd를 실행하고 그 sshd가 bash를 실행했음을 보여준다. 그리고 마지막으로 실행된 bash가 앞서 봤던 $기호를 화면에 출력한 것이다.

따라서 sshd는 사용자와 직접 대화하지 않는 백그라운드 프로세스임을 알 수 있다. 반면, 마지막에 실행된 bash는 사용자와 대화를 하기 위해 프롬프트를 띄우고 키보드로부터의 입력을 기다리고 있으므로 포그라운드 프로세그가 된다.
