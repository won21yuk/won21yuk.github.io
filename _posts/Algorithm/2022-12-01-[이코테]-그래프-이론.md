---
title: 이코테 Ch.8 그래프 이론(Graph Theory) (1)
categories: [Algorithm, Graph Theory]
---

# 서로소 집합

수학에서 서로소 집합은 공통원소가 없는 두 집합을 의미한다. 가령 {1,2}와 {3,4}는 서로소 관계다.

서로소 집합 자료구조는 서로소 부분 집합들로 나누어진 원소들의 데이터를 처리하기 위한 자료구조를 의미한다. union과 find이 두 개의 연산으로 조작이 가능하다. union(합집합) 연산은 두 개의 원소가 포함된 집항르 하나의 집합으로 합치는 연산이다. find(찾기) 연산은 특정 원소가 속한 집합이 어떤 집합인지 알려주는 연산이다. 스택과 큐가 각각 push와 pop 연산으로 이루어졌던 것 처럼 서로소 집합 자료구조는 합집합과 찾기 연산으로 구성된다.

## 서로소 집합 자료구조

서로소 집합 자료구조는 트리 자료구조를 통해 구현된다. 합집합 연산이 주어졌을 때 트리 자료구조를 이용해서 집합을 표현하는 서로소 집합 계산 알고리즘은 아래와 같다.

1. union(합집합) 연산을 확인하여 서로 연결된 두 노드 A,B를 확인
    1. A와 B의 루트노드 A’, B’를 각각 찾기
    2. A’를 B’의 부모 노드로 설정( B’가 A’를 가리키도록 설정)
2. 모든 union 연산을 처리할 때까지 1번과정 반복

실제로 구현할 때는 A’과 B’ 중에 더 번호가 작은 원소가 부모 노드가 되도록 구현하는 경우가 일반적이다. 가령 A’이 1이고 B’이 3이면 B’이 A’을 가리키도록 설정한다.

서로소 집합 계산 알고리즘의 동작방식을 보기 위해 전체 집합이 6개의 원소로 구성된 {1,2,3,4,5,6}이라고 가정해본다. 이때 아래와 같은 4개의 union 연산이 주어진다.

- union 1,4
- union 2,3
- union 2,4
- union 5,6

union 연산은 1,4가 같은 집합 2,3이 같은 집합 등을 표현한다. 4개의 union 연산이 수행되고 전체 원소들이 결과적으로 어떠한 형태의 부분집합으로 나누어지 확인하기 위한 방법 중 하나가 그래프 형태로 표현하는 것이다.

![graph-theory-disjoint0](/images/graph-theory-disjoint0.png)

각 원소들은 그래프의 노드로 표현되고 union 연산은 간선으로 표현된다. 따라서 앞선 예시로 그려지는 그래프는 6개의 노드와 4개의 간선을 가진 그래프이다. 이 그림을 보면 바로 전체 원소들이  {1,2,3,4}와 {5,6}이라는 두 부분집합으로 나누어지는 것을 확인할 수 있다.

이제 서로소 집합 알고리즘을 자세하게 확인할 수 있다. union 연산을 하나씩 확인하면서 서로 다른 두 원소에 대해 union(합집합)을 수행해야 할 때는, 각각 루트 노드를 찾아서 더 큰 루트 노드가 더 작은 루트 노드를 가리키도록 하면 된다.

좀더 구체적인 단계로 나누어 확인해보면, 우선 초기 단계에서는 노드의 개수 크기의 부모 테이블을 초기화한다. 이때 모든 원소가 자기 자신을 부모로 가지도록 설정한다. 따라서 현재 원소의 개수가 6개면 6개의 트리가 존재하는 것이다. 다만 한가지 주의할 점은 부모 테이블은 말 그대로 부모에 대한 정보만을 담는다. 실제로 루트를 확인하고자 하면 재귀적으로 부모를 거슬러 올라가서 최종적인 루트 노드를 찾아야 한다.

| 노드번호 | 1 | 2 | 3 | 4 | 5 | 6 |
| --- | --- | --- | --- | --- | --- | --- |
| 부모 | 1 | 2 | 3 | 4 | 5 | 6 |

첫번째 union 연산을 확인하면 1과 4를 합친다. 이때 노드 1과 노드4의 루트 노드를 각각 찾으면 된다. 현재 루트 노드는 각각 1과 4이기 때문에 더 큰 번호에 해당하는 루트 노드 4의 부모를 1로 설정한다.

![graph-theory-disjoint1](/images/graph-theory-disjoint1.png)

그 다음 union 연산을 확인하면 2,3을 합친다. 더 큰 번호에 해당하는 루트 노드 3의 부모를 2로 설정한다. 이런식으로 반복하면 최종 부모 테이블은 아래와 같다.

| 노드번호 | 1 | 2 | 3 | 4 | 5 | 6 |
| --- | --- | --- | --- | --- | --- | --- |
| 부모 | 1 | 1 | 2 | 1 | 5 | 5 |

여기서 한가지 주의해야할 것은 루트 노드를 즉시 계산할 수 없고 부모 테이블을 계속해서 확인하며 거슬러 올라가야한 다는 것이다. 가령 노드 3의 부모노드는 2이고 노드 2의 부모노드는 1이기 때문에 노드 3의 루트 노드는 1이다라는 식으로 알고리즘이 진행된다. 다시 말하자면 서로소 집합 알고리즘으로 루트 노드를 찾기 위해서는 재귀적으로 부모를 거슬러 올라가야한다. 이 내용들을 코드로 구현하면 아래와 같다.

```python
# 특정 원소가 속한 집합 찾기
def find_parent(parent, x):
	# 루트 노드가 아니라면 루트 노드를 찾을 때까지 재귀적으로 호출
	if parent[x] != x:
		return find_parent(parent, parent[x])
	return x

# 두 원소가 속한 집합을 합치기
def union_parent(parent, a, b):
	a = find_parent(parent, a)
	b = find_parent(parent, b)
	if a < b:
		parent[b] = a
	else:
		parent[a] = b

# 노드의 개수와 간선의 개수(=union 연산의 개수) 입력받기
v, e = map(int, input().split())
# 부모 테이블 초기화
parent = [0] * (v+1)

# 부모 테이블상에서 부모를 자기 자신으로 초기화
for i in range(1, v+1):
	parent[i] = i

# union 연산을 각각 수행
for i in range(e):
	a, b = map(int, input().split())
	union_parent(parent, a, b)

# 각 원소가 속한 집합 출력
print('각 원소가 속한 집합: ', end='')
for i in range(1, v+1):
	print(find_parent(parent, i), end=' ')

print()

# 부모 테이블 내용 출력
print('부모 테이블: ', end='')
for i in range(1, v+1):
	print(parent[i], end=' ')
```

결과적으로 모든 원소에 대해 각 원소가 속한 집합을 출력하니 1,1,1,1,5,5라고 출력된다. 이는 1부터 6까지의 원소의 루트 노드가 1,1,1,1,5,5라는 의미이다. 이 루트 노드가 같은 원소끼리는 동일한 집합을 이룬다. 즉, {1,2,3,4}와 {5,6}으로 전체 원소가 나뉜다는 것이다.

다만, 이 방식은 find 함수가 비효율적이라는 단점이 있다. 최악의 경우 find 함수는 모든 노드를 다 확인하기 때문에 시간복잡도는 O(V)이다. 그리고 find 혹은 union 연산의 개수가 M개라면 전체 시간복잡도는 O(VM)까지 되기 때문에 비효율적이다.

그런데 이 find 함수는 경로 압축 기법을 적용하여 아주 간단히 최적화가능하다. 경로 압축은 find함수를 재귀적으로 호출한 뒤에 부모 테이블 값을 갱신하는 기법이다. 기존의 find 함수를 아래와 같이 변경하면 경로 압축 기법의 구현이 완료된다.

```python
def find_parent(parent, x):
	if parent[x] != x:
		parent[x] = find_parent(parent, parent[x])
	return parent[x]
```

이렇게 함수를 수정하면 각 노드에 대해 find 함수를 호출한 후 해당 노드의 루트 노드가 바로 부모노드가 된다.

## 서로소 집합을 활용한 사이클 판별

서로소 집합은 무방향 그래프 내에서의 사이클을 판별할 때도 사용가능하다.

앞서 union 연산을 그래프에서의 간선을 표혔했던것을 떠올리면, 간선을 하나씩 확인하면서 두 노드가 포함되어 있는 집합을 합치는 과정을 반복하는 것으로 사이클을 판별할 수 있다. 해당 알고리즘은 아래와 같다.

1. 각 간선을 확인하며 두 노드의 루트 노드 확인
    1. 루트 노드가 서로 다르다면 두 노드에 대하여 union 연산을 수행
    2. 루트 노드가 서로 같다면 사이클이 발생한 것
2. 그래프에 포함되어 있는 모든 간선에 대해 1번과정 반복

![graph-theory-disjoint2](/images/graph-theory-disjoint2.png)

좀더 구체적인 단계를 확인하기 위해 위의 그래프의 사이클을 판별하는 과정을 살펴본다.

우선 모든 노드에 대하여 자기 자신을 부모로 설정하는 형태로 부모 테이블을 초기화 한다. 그리고 가장 먼저 간선 (1,2)를 확인한다. 노드 1과 노드 2의 루트 노드는 각각 1과 2 이다. 따라서 더 큰 번호를 갖는 도드 2의 부모 노드를 1로 변경한다. 이어서 간선 (1,3)을 확인한다. 노드 1과 노드 3의 루트 노드는 각각 1과 3이다. 따라서 더 큰 번호를 갖는 노드 3의 부모노드를 1로 변경한다. 이후 (2,3)을 확인하면 노드 2와 노드3이 이미 루트 노드로 노드 1을 갖고 있다. 따라서 사이클이 발생한다는 것을 알 수 있다. 이를 코드로 작성하면 아래와 같다.

```python
# 특정 원소가 속한 집합 찾기
def find_parent(parent, x):
	# 루트 노드가 아니라면 루트 노드를 찾을 때까지 재귀적으로 호출
	if parent[x] != x:
		parent[x] = find_parent(parent, parent[x])
	return parent[x]

# 두 원소가 속한 집합을 합치기
def union_parent(parent, a, b):
	a = find_parent(parent, a)
	b = find_parent(parent, b)
	if a < b:
		parent[b] = a
	else:
		parent[a] = b

# 노드의 개수와 간선의 개수(=union 연산의 개수) 입력받기
v, e = map(int, input().split())
# 부모 테이블 초기화
parent = [0] * (v+1)

# 부모 테이블상에서 부모를 자기 자신으로 초기화
for i in range(1, v+1):
	parent[i] = i

# 사이클 발생여부
cycle = False

# union 연산을 각각 수행
for i in range(e):
	a, b = map(int, input().split())
	# 사이클이 발생하면 종료
	if find_parent(parent, a) == find_parent(parent, b):
		cycle = True
		break
	# 사이클이 발생하지 않았다면 합집합 수행
	else:
		union_parent(parent, a, b)

if cycle:
	print("사이클이 발생했습니다."
else:
	print("사이클이 발생하지 않았습니다.")
```

이러한 사이클 판별 알고리즘은 그래프에 포함되어 잇는 간선의 개수가 E개 일 때 모든 간선을 하나씩 확인하며 매 간선에 대하여 union 및 find 함수를 호출하는 방식으로 작동한다. 추가로 이 알고리즘은 간선에 방향성이 없는 무향 그래프에서만 적용이 가능하다.
